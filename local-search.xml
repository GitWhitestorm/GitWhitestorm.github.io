<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RabbitMQ在Go语言中的使用</title>
    <link href="/2022/06/11/RabbitMQ%E5%9C%A8Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/06/11/RabbitMQ%E5%9C%A8Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>RabbitMQ is a message broker: it accepts and forwards messages. You can think about it as a post office: when you put the mail that you want posting in a post box, you can be sure that the letter carrier will eventually deliver the mail to your recipient. In this analogy, RabbitMQ is a post box, a post office, and a letter carrier.</p></blockquote><ul><li>简单来说就是RabbitMQ起到的是快递公司作用，寄件人就是生产者，收件人就是消费者</li><li>不过相比快递公司又多了许多功能，例如生产者生产的信息可以被多个消费者使用<br><img src="https://upload-images.jianshu.io/upload_images/27509643-a4371b13a765702b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PQC模型示意图"></li></ul><h3 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h3><ul><li>发送消息的程序就是生产者（Producer），接收消息或者等待接收消息的程序就是消费者（Consumer）</li><li>队列（Queue）是生产者到消费者信息传递的（物理和逻辑上的）载体</li></ul><h2 id="服务端安装"><a href="#服务端安装" class="headerlink" title="服务端安装"></a>服务端安装</h2><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><p>其他安装方式可以去rabbitMQ官网查询</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">下载带有web管理界面的镜像</span><br>docker pull rabbitmq:3.8.2-management <br><span class="hljs-meta prompt_">#</span><span class="language-bash">启动容器</span><br>docker run -p 1883:1883 -p 4369:4369 -p 5671:5671 \<br>-p 5672:5672 -p 8883:8883 \<br>-p 15672:15672 -p 25672:25672 \<br>-p 15675:15675 \<br>-d --hostname my-rabbitmq \<br>--name some-rabbitmq \<br>-e RABBITMQ_DEFAULT_USER=admin \<br>-e RABBITMQ_DEFAULT_PASS=admin \<br>rabbitmq:3.8.2-management <br></code></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ul><li>访问localhost:15672<br><img src="https://upload-images.jianshu.io/upload_images/27509643-fec80ebea6c1ccbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RabbitMQ启动页面"></li><li>Username和Password都是<code>guest</code></li></ul><h2 id="Go客户端"><a href="#Go客户端" class="headerlink" title="Go客户端"></a>Go客户端</h2><ul><li>新建一个go项目</li><li>在项目根地址运行<code>go get github.com/streadway/amqp</code>命令</li><li>在项目根地址新建一个<code>producer</code>和<code>consumer</code>文件夹</li><li>在<code>producer</code>中新建<code>send.go</code>,在<code>consumer</code>中新建<code>receive.go</code><h3 id="send-go"><a href="#send-go" class="headerlink" title="send.go"></a>send.go</h3><img src="https://upload-images.jianshu.io/upload_images/27509643-a17b78fcd76f52f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="发送"></li></ul><blockquote><p>我们需要在该文件中处理发送消息的请求</p><ul><li> 导包</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;log&quot;</span><br>  <span class="hljs-string">&quot;github.com/streadway/amqp&quot;</span><br>)<br></code></pre></td></tr></table></figure><ul><li> 封装出错信息处理<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">failOnError</span><span class="hljs-params">(err <span class="hljs-type">error</span>,msg <span class="hljs-type">string</span>)</span></span>&#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span>&#123;<br>log.Fatalf(<span class="hljs-string">&quot;%s:%s&quot;</span>,msg,err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>连接RabbitMQ服务器<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">conn, err := amqp.Dial(<span class="hljs-string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)<br>failOnError(err, <span class="hljs-string">&quot;Failed to connect to RabbitMQ&quot;</span>)<br><span class="hljs-keyword">defer</span> conn.Close()<br></code></pre></td></tr></table></figure></li><li>发送到Queue中<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 声明队列</span><br><span class="hljs-comment">// 各参数作用</span><br> <span class="hljs-comment">// name为队列的名字，可以为空，如果为空队列的名字将由服务器自动生产且唯一</span><br><span class="hljs-comment">// durable为是否持久化</span><br><span class="hljs-comment">// autoDelete是否自动删除</span><br><span class="hljs-comment">// exclusive为排他性(只有同一连接共享此队列，且连接断开时队列删除)</span><br><span class="hljs-comment">// noWait阻塞声明，如果为true则要等待服务器返回结果</span><br>queue,err := ch.QueueDeclare(<br><span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-comment">// name</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// durable</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// autoDelete</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// exclusive</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// noWait</span><br><span class="hljs-literal">nil</span>, <span class="hljs-comment">// args</span><br>)<br>     body := <span class="hljs-string">&quot;HelloWorld&quot;</span><br><span class="hljs-comment">// 发送无交换机指定路由key的信息</span><br><span class="hljs-comment">// exchange为交换机名字</span><br><span class="hljs-comment">// routing key为路由键</span><br><span class="hljs-comment">// mandatory</span><br>err = ch.Publish(<br><span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// exchange</span><br>queue.Name, <span class="hljs-comment">// routing key</span><br><span class="hljs-literal">false</span>,<span class="hljs-comment">//mandatory</span><br><span class="hljs-literal">false</span>,<span class="hljs-comment">// immediate</span><br>amqp.Publishing&#123;<br>ContentType: <span class="hljs-string">&quot;text/plain&quot;</span>,<br>Body: []<span class="hljs-type">byte</span>(body),<br>&#125;)<br>failOnError(err,<span class="hljs-string">&quot;Failed to publish a message&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="receive-go"><a href="#receive-go" class="headerlink" title="receive.go"></a>receive.go</h3><img src="https://upload-images.jianshu.io/upload_images/27509643-ea3524651334c309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="接收"><blockquote><p>我们需要在该文件中接收消息</p><ul><li> 导包</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;log&quot;</span><br>  <span class="hljs-string">&quot;github.com/streadway/amqp&quot;</span><br>)<br></code></pre></td></tr></table></figure></li><li> 封装出错信息处理<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">failOnError</span><span class="hljs-params">(err <span class="hljs-type">error</span>,msg <span class="hljs-type">string</span>)</span></span>&#123;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span>&#123;<br>log.Fatalf(<span class="hljs-string">&quot;%s:%s&quot;</span>,msg,err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>连接RabbitMQ服务器<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">conn, err := amqp.Dial(<span class="hljs-string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)<br>failOnError(err, <span class="hljs-string">&quot;Failed to connect to RabbitMQ&quot;</span>)<br><span class="hljs-keyword">defer</span> conn.Close()<br></code></pre></td></tr></table></figure></li><li>声明队列<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// 再次声明，防止客户端比服务端启动得早，然后出错</span><br>queue, err := ch.QueueDeclare(<br><span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-comment">// name</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// durable</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// delete when unused</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// exclusive</span><br><span class="hljs-literal">false</span>,   <span class="hljs-comment">// no-wait</span><br><span class="hljs-literal">nil</span>,     <span class="hljs-comment">// arguments</span><br>)<br>     failOnError(err, <span class="hljs-string">&quot;Failed to declare a queue&quot;</span>)<br></code></pre></td></tr></table></figure></li><li>获取消费chan<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">msgs, err := ch.Consume(<br>queue.Name, <span class="hljs-comment">// queue</span><br><span class="hljs-string">&quot;&quot;</span>,         <span class="hljs-comment">// consumer</span><br><span class="hljs-literal">true</span>,       <span class="hljs-comment">// auto-ack</span><br><span class="hljs-literal">false</span>,      <span class="hljs-comment">// exclusive</span><br><span class="hljs-literal">false</span>,      <span class="hljs-comment">// no-local</span><br><span class="hljs-literal">false</span>,      <span class="hljs-comment">// no-wait</span><br><span class="hljs-literal">nil</span>,        <span class="hljs-comment">// args</span><br>)<br>failOnError(err, <span class="hljs-string">&quot;Failed to register a consumer&quot;</span>)<br></code></pre></td></tr></table></figure></li><li>接收chan中信息<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">       <span class="hljs-comment">// 用于阻塞主线程接收</span><br>forever := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> msgs &#123;<br>log.Println(<span class="hljs-string">&quot;Received a message&quot;</span>, <span class="hljs-type">string</span>(msg.Body))<br>&#125;<br>&#125;()<br><br>log.Printf(<span class="hljs-string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>)<br>&lt;-forever<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/06/hello-world/"/>
    <url>/2022/06/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>红黑树—2</title>
    <link href="/2022/05/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E2%80%942/"/>
    <url>/2022/05/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E2%80%942/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树—2"><a href="#红黑树—2" class="headerlink" title="红黑树—2"></a>红黑树—2</h1><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><blockquote><p><strong>如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题</strong></p></blockquote><ul><li>即如果有两个儿子的话，可以找到左子树的最大元素，将他替换到要删除的节点元素，或者可以找到右子数的最小元素</li></ul><h3 id="情况一：删除的节点为红色节点"><a href="#情况一：删除的节点为红色节点" class="headerlink" title="情况一：删除的节点为红色节点"></a>情况一：删除的节点为红色节点</h3><ul><li>父亲和儿子一定是黑色的，用<strong>黑色儿子替换它</strong></li></ul><h3 id="情况二：删除节点为黑色，它的儿子是红色"><a href="#情况二：删除节点为黑色，它的儿子是红色" class="headerlink" title="情况二：删除节点为黑色，它的儿子是红色"></a>情况二：删除节点为黑色，它的儿子是红色</h3><ul><li>重绘儿子为黑色，再将黑色儿子替换它</li><li>代码</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 替换删除字节和子节点的位置</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">delete_one_child</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node *n)</span><br>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Precondition: n has at most one non-null child.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">child</span> =</span> is_leaf(n-&gt;right)? n-&gt;left : n-&gt;right;<br> <br>        replace_node(n, child);<br>        <span class="hljs-keyword">if</span>(n-&gt;color == BLACK)&#123;<br>            <span class="hljs-comment">// 情况二：删除节点为黑色，它的儿子是红色</span><br>                <span class="hljs-keyword">if</span>(child-&gt;color == RED)<br>                        child-&gt;color = BLACK;<br>                <span class="hljs-keyword">else</span><br>                        delete_case1 (child);<br>        &#125;<br>        <span class="hljs-built_in">free</span> (n);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="情况三：删除的节点和它的儿子二者都是黑色"><a href="#情况三：删除的节点和它的儿子二者都是黑色" class="headerlink" title="情况三：删除的节点和它的儿子二者都是黑色"></a>情况三：删除的节点和它的儿子二者都是黑色</h3><blockquote><p>我们首先把要删除的节点替换为它的儿子。出于方便，称呼这个儿子为<strong>N</strong>（在新的位置上），称呼它的兄弟（它父亲的另一个儿子）为<strong>S</strong>。在下面的示意图中，我们还是使用<strong>P</strong>称呼N的父亲，<strong>SL</strong>称呼S的左儿子，<strong>SR</strong>称呼S的右儿子。N是新的根</p></blockquote><h4 id="情形一：N为根节点"><a href="#情形一：N为根节点" class="headerlink" title="情形一：N为根节点"></a>情形一：N为根节点</h4><ul><li><p>直接返回</p></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">delete_case1</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node *n)</span><br>&#123;<br>        <span class="hljs-keyword">if</span>(n-&gt;parent != <span class="hljs-literal">NULL</span>)<br>                delete_case2 (n);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="情形二：S为红色"><a href="#情形二：S为红色" class="headerlink" title="情形二：S为红色"></a>情形二：S为红色</h4><ul><li><p>对调P和S的颜色，即P重绘为红色，S重绘为黑色</p></li><li><p>如果N为P的左子节点则左旋P，如果N为P的右子节点则优璇P</p></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">delete_case2</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node *n)</span><br>&#123;<br>    <span class="hljs-comment">// 获取n的兄弟节点</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">s</span> =</span> sibling (n);<br> <br>        <span class="hljs-keyword">if</span>(s-&gt;color == RED)&#123;<br>                n-&gt;parent-&gt;color = RED;<br>                s-&gt;color = BLACK;<br>                <span class="hljs-keyword">if</span>(n == n-&gt;parent-&gt;left)<br>                        rotate_left(n-&gt;parent);<br>                <span class="hljs-keyword">else</span><br>                        rotate_right(n-&gt;parent);<br>        &#125; <br>        delete_case3 (n);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220515170919189.png" alt="情况三情形二"></p></li></ul><h4 id="情形三：P、S和S的儿子都是黑色"><a href="#情形三：P、S和S的儿子都是黑色" class="headerlink" title="情形三：P、S和S的儿子都是黑色"></a>情形三：P、S和S的儿子都是黑色</h4><ul><li><p>重绘S为红色，从情况三情形一开始递归</p></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">delete_case3</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node *n)</span><br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">s</span> =</span> sibling (n);<br> <br>        <span class="hljs-keyword">if</span>((n-&gt;parent-&gt;color == BLACK)&amp;&amp;<br>(s-&gt;color == BLACK)&amp;&amp;<br>(s-&gt;left-&gt;color == BLACK)&amp;&amp;<br>(s-&gt;right-&gt;color == BLACK)) &#123;<br>                s-&gt;color = RED;<br>                delete_case1(n-&gt;parent);<br>        &#125; <span class="hljs-keyword">else</span><br>                delete_case4 (n);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="情况四：S和S的儿子为黑色，N的父亲是红色"><a href="#情况四：S和S的儿子为黑色，N的父亲是红色" class="headerlink" title="情况四：S和S的儿子为黑色，N的父亲是红色"></a>情况四：S和S的儿子为黑色，N的父亲是红色</h3><ul><li><p>交换P和S的颜色</p></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">delete_case4</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node *n)</span><br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">s</span> =</span> sibling (n);<br> <br>        <span class="hljs-keyword">if</span>（(n-&gt;parent-&gt;color == RED)&amp;&amp;<br>(s-&gt;color == BLACK)&amp;&amp;<br>(s-&gt;left-&gt;color == BLACK)&amp;&amp;<br>(s-&gt;right-&gt;color == BLACK)) &#123;<br>                s-&gt;color = RED;<br>                n-&gt;parent-&gt;color = BLACK;<br>        &#125; <span class="hljs-keyword">else</span><br>                delete_case5 (n);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="情况五：S是黑色，S的左儿子是红色，S的右儿子是黑色，而N是它父亲的左儿子"><a href="#情况五：S是黑色，S的左儿子是红色，S的右儿子是黑色，而N是它父亲的左儿子" class="headerlink" title="情况五：S是黑色，S的左儿子是红色，S的右儿子是黑色，而N是它父亲的左儿子"></a>情况五：S是黑色，S的左儿子是红色，S的右儿子是黑色，而N是它父亲的左儿子</h3><ul><li><p>右旋转S</p></li><li><p>交换S和S的新父亲节点的颜色</p></li><li><p>代码</p></li><li><p>```c<br>void delete_case5(struct node *n)<br>{</p><pre><code class="hljs">    struct node *s = sibling (n);    if（s-&gt;color == BLACK)&#123; /* this if statement is trivial, </code></pre><p>due to Case 2(even though Case two changed the sibling to a sibling’s child,<br>the sibling’s child can’t be red, since no red parent can have a red child). */<br>// the following statements just force the red to be on the left of the left of the parent,<br>// or right of the right, so case six will rotate correctly.</p><pre><code class="hljs">            if((n == n-&gt;parent-&gt;left)&amp;&amp;</code></pre><p>(s-&gt;right-&gt;color == BLACK)&amp;&amp;<br>(s-&gt;left-&gt;color == RED)) { // this last test is trivial too due to cases 2-4.</p><pre><code class="hljs">                    s-&gt;color = RED;                    s-&gt;left-&gt;color = BLACK;                    rotate_right (s);            &#125; else if((n == n-&gt;parent-&gt;right)&amp;&amp;</code></pre><p>(s-&gt;left-&gt;color == BLACK)&amp;&amp;<br>(s-&gt;right-&gt;color == RED)) {// this last test is trivial too due to cases 2-4.</p><pre><code class="hljs">                    s-&gt;color = RED;                    s-&gt;right-&gt;color = BLACK;                    rotate_left (s);            &#125;    &#125;    delete_case6 (n);</code></pre><p>}</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xl"><br>### 情况六：S是黑色，S的右儿子是红色，而N是它父亲的左儿子<br><br>- 对P做左旋<br>- 交换P和S的颜色，并使S的右儿子为黑色<br><br>- 代码<br><br>  ``` c<br>  void delete_case6(struct node *n)<br>  &#123;<br>          struct node *s = sibling (n);<br>   <br>          <span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">color</span> = n-&gt;</span><span class="hljs-function"><span class="hljs-title">parent</span>-&gt;</span><span class="hljs-built_in">color</span>;<br>          <span class="hljs-function"><span class="hljs-title">n</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">parent</span>-&gt;</span><span class="hljs-built_in">color</span> = BLACK;<br>   <br>          <span class="hljs-function"><span class="hljs-title">if</span>(n == n-&gt;</span><span class="hljs-function"><span class="hljs-title">parent</span>-&gt;</span>left)&#123;<br>                  <span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span><span class="hljs-built_in">color</span> = BLACK;<br>                  <span class="hljs-function"><span class="hljs-title">rotate_left</span>(n-&gt;</span>parent);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-function"><span class="hljs-title">s</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span><span class="hljs-built_in">color</span> = BLACK;<br>                  <span class="hljs-function"><span class="hljs-title">rotate_right</span>(n-&gt;</span>parent);<br>          &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220515174226354.png" alt="情况六"></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1]<a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91</a></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><ul><li>红黑树的插入和删除较为复杂，不必强记</li><li>理解红黑树的性质较为重要</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树—1</title>
    <link href="/2022/05/08/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2022/05/08/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树—1"><a href="#红黑树—1" class="headerlink" title="红黑树—1"></a>红黑树—1</h1><h2 id="为什么使用红黑树"><a href="#为什么使用红黑树" class="headerlink" title="为什么使用红黑树"></a>为什么使用红黑树</h2><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><blockquote><ol><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li></ol></blockquote><p><strong>缺点</strong>：最坏情况下查找的复杂度为<code>O（n）</code></p><h3 id="AVL平衡树"><a href="#AVL平衡树" class="headerlink" title="AVL平衡树"></a>AVL平衡树</h3><blockquote><p>任一节点对应的两棵子树的最大高度差为1的二叉搜索树</p></blockquote><p><strong>缺点</strong>：删除和插入需要频繁的调整，性能较差</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><blockquote><p>红黑树是每个节点都带有<em>颜色</em>属性的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">二叉查找树</a>，颜色为<em>红色</em>或<em>黑色</em></p></blockquote><p><strong>性质</strong></p><ol><li>节点是红色或黑色。</li><li>根是黑色。</li><li>所有叶子都是黑色（叶子是NIL节点）。</li><li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li><li>从任一节点到其每个叶子的所有<a href="https://zh.wikipedia.org/wiki/%E9%81%93%E8%B7%AF_(%E5%9B%BE%E8%AE%BA)">简单路径</a>都包含相同数目的黑色节点。</li></ol><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220508154834636.png" alt="红黑树图示"></p><p>上述性质保证了<strong>最长路径最大是最短路径的2倍</strong></p><p><strong>原因</strong></p><ul><li>性质4说明了路径不能有两个连续的红色节点</li><li>性质5所有最长的路径都有相同数目的黑色节点</li><li>最短路径为黑色，最长路径为红黑交替，又因为黑色节点数目是相同，所以保证了最长路径最大是最短路径的2倍</li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><blockquote><p>与普通的二叉搜索树相同</p></blockquote><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul><li>我们首先<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91#%E6%8F%92%E5%85%A5">以二叉查找树的方法</a>增加节点并标记它为红色。<ul><li>如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整。</li></ul></li></ul><p>插入的时候性质的状态：</p><ul><li>性质1和性质3总是保持着。</li><li>性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。</li><li>性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁。</li></ul><p><strong>我们假设将要插入的节点标为N，N的父节点标为P，N的祖父节点标为G，N的叔父节点标为U。</strong></p><ul><li>首先方便代码的书写，我们定义两个函数获取要插入节点的祖父节点和叔父节点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">node* <span class="hljs-title function_">grandparent</span><span class="hljs-params">(node *n)</span>&#123;<br>    <span class="hljs-keyword">return</span> n-&gt;parent-&gt;parent;<br>&#125;<br><br>node* <span class="hljs-title function_">uncle</span><span class="hljs-params">(node *n)</span>&#123;<br>    <span class="hljs-keyword">if</span>(n-&gt;parent == grandparent(n)-&gt;left)<br>        <span class="hljs-keyword">return</span> grandparent (n)-&gt;right;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> grandparent (n)-&gt;left;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="情况一-要插入的N的为根节点"><a href="#情况一-要插入的N的为根节点" class="headerlink" title="情况一 :要插入的N的为根节点"></a>情况一 :要插入的N的为根节点</h4><ul><li><p>在这种情形下，我们把它重绘为黑色以满足性质2。</p></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_case1</span><span class="hljs-params">(node *n)</span>&#123;<br>    <span class="hljs-keyword">if</span>(n-&gt;parent == <span class="hljs-literal">NULL</span>)<br>        n-&gt;color = BLACK;<br>    <span class="hljs-keyword">else</span><br>        insert_case2 (n);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="情况二：新节点的父节点P是黑色"><a href="#情况二：新节点的父节点P是黑色" class="headerlink" title="情况二：新节点的父节点P是黑色"></a>情况二：新节点的父节点P是黑色</h4><ul><li><p>这种情况下，性质4没有失效，其他性质也未受到威胁，所以树仍然有效</p></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_case2</span><span class="hljs-params">(node *n)</span>&#123;<br>    <span class="hljs-keyword">if</span>(n-&gt;parent-&gt;color == BLACK)<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* 树仍旧有效*/</span><br>    <span class="hljs-keyword">else</span><br>        insert_case3 (n);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>下列情况中，我们假设<strong>节点的父节点是红色</strong>，所以它有祖父节点，叔父节点</p><h4 id="情况三：父节点P和叔父节点U二者都是红色"><a href="#情况三：父节点P和叔父节点U二者都是红色" class="headerlink" title="情况三：父节点P和叔父节点U二者都是红色"></a>情况三：父节点P和叔父节点U二者都是红色</h4><ul><li><p>这种情况下，将父节点和叔父节点重绘为黑色，祖父节点重绘为红色（保证性质5）</p></li><li><p>但是如果<strong>祖父节点是根节点</strong>的话，<strong>违反了性质2</strong>，也有可能<strong>祖父节点的父节点是红色</strong>，<strong>违反了性质4</strong></p></li><li><p>为了防止以上两种状况的出现，我们递归的进行情况1的过程，即把G当成是新加入的节点进行各种情况的检查</p></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_case3</span><span class="hljs-params">(node *n)</span>&#123;<br>    <span class="hljs-keyword">if</span>(uncle(n) != <span class="hljs-literal">NULL</span> &amp;&amp; uncle (n)-&gt;color == RED) &#123;<br>        n-&gt;parent-&gt;color = BLACK;<br>        uncle (n)-&gt;color = BLACK;<br>        grandparent (n)-&gt;color = RED;<br>        insert_case1(grandparent(n));<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        insert_case4 (n);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220509112017358.png" alt="情况三"></p></li></ul><h4 id="情况四：父节点P是红色而叔父节点U是黑色或缺少"><a href="#情况四：父节点P是红色而叔父节点U是黑色或缺少" class="headerlink" title="情况四：父节点P是红色而叔父节点U是黑色或缺少"></a>情况四：父节点P是红色而叔父节点U是黑色或缺少</h4><ul><li><p>情形一</p><ul><li>新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点</li></ul><p>则左旋节点</p><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220509113446974.png" alt="情况四情形一"></p></li><li><p>情形二</p><ul><li>新节点N是其父节点P的左子节点而父节点P又是其父节点的右子节点</li></ul><p>则右旋节点</p></li><li><p>此时性质4失效，转入情况5处理</p></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_case4</span><span class="hljs-params">(node *n)</span>&#123;<br>    <span class="hljs-keyword">if</span>(n == n-&gt;parent-&gt;right &amp;&amp; n-&gt;parent == grandparent(n)-&gt;left) &#123;<br>  <br>        rotate_left(n);<br>        n = n-&gt;left;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n == n-&gt;parent-&gt;left &amp;&amp; n-&gt;parent == grandparent(n)-&gt;right) &#123;<br>        rotate_right(n);<br>        n = n-&gt;right;<br>    &#125;<br>    insert_case5 (n);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="情况五：父节点P是红色而叔父节点U是黑色或缺少"><a href="#情况五：父节点P是红色而叔父节点U是黑色或缺少" class="headerlink" title="情况五：父节点P是红色而叔父节点U是黑色或缺少"></a>情况五：父节点P是红色而叔父节点U是黑色或缺少</h4><ul><li><p>情形一</p><ul><li><p>新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点</p></li><li><p>我们进行针对祖父节点G的一次右旋转</p></li><li><p>将父节点P重绘为黑色，将祖父节点G重绘为红色</p><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220509115538593.png" alt="情况五情形一"></p></li></ul></li><li><p>情形二</p><ul><li>新节点N是其父节点的右子节点，而父节点P又是其父节点G的右子节点</li><li>我们进行针对祖父节点G的一次左旋转</li><li>将父节点P重绘为黑色，将祖父节点G重绘为红色</li></ul></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insert_case5</span><span class="hljs-params">(node *n)</span>&#123;<br>    n-&gt;parent-&gt;color = BLACK;<br>    grandparent (n)-&gt;color = RED;<br>    <span class="hljs-keyword">if</span>(n == n-&gt;parent-&gt;left &amp;&amp; n-&gt;parent == grandparent(n)-&gt;left) &#123;<br>        rotate_right(n-&gt;parent);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* Here, n == n-&gt;parent-&gt;right &amp;&amp; n-&gt;parent == grandparent (n)-&gt;right */</span><br>        rotate_left(n-&gt;parent);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]<a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91#%E5%88%A0%E9%99%A4">https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91#%E5%88%A0%E9%99%A4</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳表（skip list）</title>
    <link href="/2022/05/07/%E8%B7%B3%E8%A1%A8%EF%BC%88skip-list%EF%BC%89/"/>
    <url>/2022/05/07/%E8%B7%B3%E8%A1%A8%EF%BC%88skip-list%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><h2 id="跳表的定义"><a href="#跳表的定义" class="headerlink" title="跳表的定义"></a>跳表的定义</h2><blockquote><p><strong>跳跃列表</strong>是一种<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>。它使得包含n个元素的有序<a href="https://zh.wikipedia.org/wiki/%E5%BA%8F%E5%88%97">序列</a>的查找和插入操作的平均时间复杂度都是O(logn)，优于<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84">数组</a>的O(n)复杂度。</p></blockquote><ul><li>跳表是<strong>可以实现二分查找的有序链表</strong></li></ul><h2 id="跳表的数据结构"><a href="#跳表的数据结构" class="headerlink" title="跳表的数据结构"></a>跳表的数据结构</h2><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220507111005079.png" alt="跳表"></p><ul><li>level0为原始数据</li><li>level1则为一级索引</li><li>levelk为k级索引</li><li>k最小为2</li></ul><h3 id="跳表的时间复杂度"><a href="#跳表的时间复杂度" class="headerlink" title="跳表的时间复杂度"></a>跳表的时间复杂度</h3><blockquote><p>时间复杂度 = 索引的高度*每层索引遍历元素的个数</p></blockquote><ul><li>假设没两个节点抽出一个节点作为上一级索引的节点，原始链表为n个节点</li><li>则一级索引有n/2个节点，二级索引有n/4节点，k级索引有n/2^h个节点,最高索引有两个元素，即2 = n/2^h,即h = log2n-1,最高级索引的高度加上原始数据一层，跳表的总高度h=log2n</li></ul><h3 id="索引的更新问题"><a href="#索引的更新问题" class="headerlink" title="索引的更新问题"></a>索引的更新问题</h3><blockquote><p>链表的增删改都会涉及到索引的更新问题</p></blockquote><ul><li><p>如何知道该节点应该有几级索引？</p><ul><li>可以用一个概率函数来判断该节点有几级索引</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *skipList)</span></span>randLevel() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>;i&lt;=s.level; i++ &#123;<br>r := rand.Int()<br><span class="hljs-keyword">if</span> r % <span class="hljs-number">2</span>  == <span class="hljs-number">0</span>&#123;<br><span class="hljs-keyword">return</span> i<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> s.level<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><ul><li>从顶层链表的首元素开始，从左往右搜索</li><li>如果当前节点的下一个节点大于等于目标节点或已到达链表尾部，则转入当前节点的下一层搜索</li><li>全部层数搜索完，如果当前节点不是尾节点，让当前节点指向下一个节点，然后比较是否相同，如相同则返回，不是则返回空值</li></ul><h4 id="搜素返回前置节点数组（用于增删改）"><a href="#搜素返回前置节点数组（用于增删改）" class="headerlink" title="搜素返回前置节点数组（用于增删改）"></a>搜素返回前置节点数组（用于增删改）</h4><ul><li><p>与<strong>搜索函数</strong>相比，不用比较搜索到节点的值</p></li><li><p>与<strong>搜索函数</strong>相比，多了存储目标节点的全部层数前置节点</p></li></ul><h3 id="插入（修改）"><a href="#插入（修改）" class="headerlink" title="插入（修改）"></a>插入（修改）</h3><ul><li><p>利用<strong>搜素返回插入前置节点数组</strong>函数，如果返回的当前节点等于目标元素的值，则更新节点</p></li><li><p>利用随机函数生成需要插入的level</p></li><li><p>将其插入对搜素函数返回的previousNodes数组后，层数由随机函数生成的level决定</p></li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>利用<strong>搜素返回插入前置节点数组</strong>函数，比较返回的当前节点的值，不相等则直接返回</li><li>则将前置节点数组指向当前节点的下一层</li></ul><h2 id="Go语言实现"><a href="#Go语言实现" class="headerlink" title="Go语言实现"></a>Go语言实现</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 节点数据结构</span><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span>&#123;<br><span class="hljs-comment">// 节点的索引值</span><br>index <span class="hljs-type">uint64</span><br><span class="hljs-comment">// 节点真正的数据</span><br>value <span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-comment">// 节点的下一组节点</span><br>nextNodes []*Node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewNode</span><span class="hljs-params">(index <span class="hljs-type">uint64</span>, value <span class="hljs-keyword">interface</span>&#123;&#125;, level <span class="hljs-type">int</span>)</span></span>*Node&#123;<br><span class="hljs-keyword">return</span> &amp;Node&#123;<br>index: index,<br>value: value,<br>nextNodes: <span class="hljs-built_in">make</span>([]*Node, level),<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="跳表-1"><a href="#跳表-1" class="headerlink" title="跳表"></a>跳表</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 跳表数据结构</span><br><span class="hljs-keyword">type</span> skipList <span class="hljs-keyword">struct</span>&#123;<br><span class="hljs-comment">// 跳表的高度</span><br>level <span class="hljs-type">int</span><br><span class="hljs-comment">// 跳表的长度</span><br>length <span class="hljs-type">int32</span><br><span class="hljs-comment">// 头结点</span><br>head *Node<br><span class="hljs-comment">// 尾节点</span><br>tail *Node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSkipList</span><span class="hljs-params">(level <span class="hljs-type">int</span>)</span></span>*skipList&#123;<br>head := NewNode(<span class="hljs-number">0</span>,<span class="hljs-literal">nil</span>,level)<br><span class="hljs-keyword">var</span> tail *Node<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(head.nextNodes);i++&#123;<br>head.nextNodes[i] = tail<br>&#125;<br><span class="hljs-keyword">return</span> &amp;skipList&#123;<br>level: level,<br>length: <span class="hljs-number">0</span>,<br>head: head,<br>tail: tail,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="搜索函数"><a href="#搜索函数" class="headerlink" title="搜索函数"></a>搜索函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *skipList)</span></span>SearchWithoutPreviousNodes(index <span class="hljs-type">uint64</span>)*Node&#123;<br>currentNode := s.head<br><br><span class="hljs-keyword">for</span> l := s.level<span class="hljs-number">-1</span>;l&gt;=<span class="hljs-number">0</span>;l--&#123;<br><span class="hljs-comment">// 如果当前节点的下一个节点大于index，则转入下一层</span><br><span class="hljs-keyword">for</span> currentNode.nextNodes[l] != s.tail &amp;&amp; currentNode.nextNodes[l].index &lt; index&#123;<br>currentNode = currentNode.nextNodes[l]<br>&#125;<br>&#125;<br><span class="hljs-comment">// 如果不是尾节点则让currentNode指向大于等于index的节点</span><br><span class="hljs-keyword">if</span> currentNode.nextNodes[<span class="hljs-number">0</span>] != s.tail&#123;<br>currentNode = currentNode.nextNodes[<span class="hljs-number">0</span>]<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">// 如果是尾节点直接返回</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// 等于则返回</span><br><span class="hljs-keyword">if</span> currentNode.index == index&#123;<br><span class="hljs-keyword">return</span> currentNode<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="搜索函数（前置节点数组）"><a href="#搜索函数（前置节点数组）" class="headerlink" title="搜索函数（前置节点数组）"></a>搜索函数（前置节点数组）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *skipList)</span></span>SearchWithPreviousNodes(index <span class="hljs-type">uint64</span>)([]*Node,*Node)&#123;<br>previousNodes := <span class="hljs-built_in">make</span>([]*Node,s.level)<br><br>currentNode := s.head<br><br><span class="hljs-keyword">for</span> l := s.level<span class="hljs-number">-1</span>;l&gt;=<span class="hljs-number">0</span>;l--&#123;<br><span class="hljs-comment">// 直到当前节点的下一个节点值为尾节点或者当前节点的下一个节点值的index&gt;=index循环终止</span><br><span class="hljs-comment">// 此时当前节点的下一个节点即是目标节点</span><br><span class="hljs-keyword">for</span> currentNode.nextNodes[l] != s.tail &amp;&amp; currentNode.nextNodes[l].index &lt; index&#123;<br>currentNode = currentNode.nextNodes[l]<br>&#125;<br><span class="hljs-comment">// 记录当前节点</span><br>previousNodes[l] = currentNode<br><br>&#125;<br><br><span class="hljs-keyword">if</span> currentNode.nextNodes[<span class="hljs-number">0</span>] != s.tail&#123;<br>currentNode = currentNode.nextNodes[<span class="hljs-number">0</span>]<br>&#125;<br><span class="hljs-keyword">return</span> previousNodes,currentNode<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入（修改）-1"><a href="#插入（修改）-1" class="headerlink" title="插入（修改）"></a>插入（修改）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *skipList)</span></span>Insert(index <span class="hljs-type">uint64</span>,value <span class="hljs-keyword">interface</span>&#123;&#125;)&#123;<br>previousNodes,currentNode := s.SearchWithPreviousNodes(index)<br><br><span class="hljs-comment">// 已存在该节点更新节点的值</span><br><span class="hljs-keyword">if</span> currentNode != s.head &amp;&amp; currentNode.index == index&#123;<br>currentNode.value = value<br><span class="hljs-keyword">return</span><br>&#125;<br><br>newNode := NewNode(index,value,s.randLevel())<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(newNode.nextNodes)<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i++&#123;<br>newNode.nextNodes[i] = previousNodes[i].nextNodes[i]<br>previousNodes[i].nextNodes[i] = newNode<br><span class="hljs-comment">// 释放内存</span><br>previousNodes[i] = <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// 原子指令，长度加1</span><br>atomic.AddInt32(&amp;s.length,<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 释放内存</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(newNode.nextNodes);i&lt;<span class="hljs-built_in">len</span>(previousNodes);i++&#123;<br>previousNodes[i] = <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s *skipList)</span></span>Delete(index <span class="hljs-type">uint64</span>)&#123;<br>previousNodes,currentNode := s.SearchWithPreviousNodes(index)<br><br><span class="hljs-keyword">if</span> currentNode != s.head &amp;&amp; currentNode.index == index&#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(currentNode.nextNodes);i++&#123;<br><br>previousNodes[i].nextNodes[i] = currentNode.nextNodes[i]<br>currentNode.nextNodes = <span class="hljs-literal">nil</span><br>previousNodes[i] = <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// 减少指令</span><br>atomic.AddInt32(&amp;s.length,<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(currentNode.nextNodes); i &lt; <span class="hljs-built_in">len</span>(previousNodes); i++ &#123;<br>previousNodes[i] = <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跳表</tag>
      
      <tag>skiplist</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输入网址到页面显示的过程</title>
    <link href="/2022/05/01/%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/05/01/%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="输入网址到页面显示的过程"><a href="#输入网址到页面显示的过程" class="headerlink" title="输入网址到页面显示的过程"></a>输入网址到页面显示的过程</h1><h2 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h2><ul><li>解析URL</li><li>生成HTTP报文</li></ul><h2 id="DNS（获取IP地址）"><a href="#DNS（获取IP地址）" class="headerlink" title="DNS（获取IP地址）"></a>DNS（获取IP地址）</h2><ul><li>查询服务器域名对应的IP地址</li></ul><h2 id="TCP（可靠传输）"><a href="#TCP（可靠传输）" class="headerlink" title="TCP（可靠传输）"></a>TCP（可靠传输）</h2><ul><li>TCP三次握手</li><li>如果超过MSS则分片</li><li>TCP报文</li></ul><h2 id="IP（指路）"><a href="#IP（指路）" class="headerlink" title="IP（指路）"></a>IP（指路）</h2><ul><li>IP报文生成</li></ul><h2 id="MAC（两点传输）"><a href="#MAC（两点传输）" class="headerlink" title="MAC（两点传输）"></a>MAC（两点传输）</h2><ul><li>生成MAC报文<ul><li>ARP协议根据IP找到MAC地址</li></ul></li></ul><h2 id="网卡（出口）"><a href="#网卡（出口）" class="headerlink" title="网卡（出口）"></a>网卡（出口）</h2><ul><li>添加<strong>报头和起始帧分界符</strong><ul><li>起始帧分界符是⼀个⽤来表示包起始位置的标记</li></ul></li><li>在末尾添加<strong>⽤于检测错误的帧校验序列</strong><ul><li>末尾的 FCS （帧校验序列）⽤来检查包传输过程是否有损坏</li></ul></li><li>将数字信息转换为电信号</li></ul><p>报头和起始帧分界符</p><h2 id="交换机（交换机本身没有MAC地址）"><a href="#交换机（交换机本身没有MAC地址）" class="headerlink" title="交换机（交换机本身没有MAC地址）"></a>交换机（交换机本身没有MAC地址）</h2><ol><li><p>电信号到达⽹线接⼝，交换机⾥的模块进⾏接收</p></li><li><p>将电信号转换为数字信号</p></li><li><p>进行差错检测，没问题则放到缓存区</p></li><li><p>查询包的接收方MAC地址</p></li><li><p>根据交换机的MAC地址表进行转发</p><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220501141716242.png" alt="交换机MAC地址表"></p></li><li><p>如果没有找到，则每个端口都发，只有相应的接收者才接收包，⽽其他设备则会忽略这个包。如果有端口响应了，则返回该将该端口MAC地址写入交换机MAC表</p></li></ol><h2 id="路由器（出境大门）"><a href="#路由器（出境大门）" class="headerlink" title="路由器（出境大门）"></a>路由器（出境大门）</h2><ul><li>路由器有自己的IP和MAC地址，可以作为以太网包的接收方和发送方</li></ul><h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><ul><li>信号转换：将电信号转换数字信号</li><li>差错检错</li><li>检查MAC头部中的接收方是否是自己的MAC地址，如果是就放入缓冲区，不是就丢弃</li></ul><h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><ul><li>查询路由表确定输出端口</li><li>完成接收操作后，路由器会去掉包开头的<code>MAC头部</code></li><li>根据<code>IP头部</code>查看路由器的路由表</li><li>如果匹配到路由，则选择匹配到的路由，如果匹配不到则选择默认路由</li></ul><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220501150206742.png" alt="路由表图解"></p><h4 id="发送阶段"><a href="#发送阶段" class="headerlink" title="发送阶段"></a>发送阶段</h4><ul><li>知道对方的IP后，通过ARP协议查询MAC地址，并将结果作为接收方的MAC地址，MAC头部的发送地址则为路由器的地址</li></ul><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220501153854705.png" alt="流程图解"></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>本篇文章图一、图二来自《图解网络-小林》</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>TCP</tag>
      
      <tag>IP</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP基本认识</title>
    <link href="/2022/04/30/TCP%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/"/>
    <url>/2022/04/30/TCP%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP基本认识"><a href="#TCP基本认识" class="headerlink" title="TCP基本认识"></a>TCP基本认识</h1><h2 id="TCP定义"><a href="#TCP定义" class="headerlink" title="TCP定义"></a>TCP定义</h2><ul><li>面向连接的、可靠的、基于字节流的传输层通信协议</li></ul><h2 id="TCP连接定义"><a href="#TCP连接定义" class="headerlink" title="TCP连接定义"></a>TCP连接定义</h2><ul><li>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合有Socket、序列号和窗口大小</li></ul><h2 id="TCP、UDP区别"><a href="#TCP、UDP区别" class="headerlink" title="TCP、UDP区别"></a>TCP、UDP区别</h2><h3 id="1、连接"><a href="#1、连接" class="headerlink" title="1、连接"></a>1、连接</h3><ul><li>TCP是面向连接的传输层协议，传输数据前要先建立连接</li><li>UDP是不需要连接的，即刻传输数据</li></ul><h3 id="2、服务对象"><a href="#2、服务对象" class="headerlink" title="2、服务对象"></a>2、服务对象</h3><ul><li>TCP是一对一的两点服务，即一条连接只有两个端点</li><li>UDP支持一对一、一对多、多对多通信</li></ul><h3 id="3、可靠性"><a href="#3、可靠性" class="headerlink" title="3、可靠性"></a>3、可靠性</h3><ul><li>TCP是可靠交付数据</li><li>UDP是尽最大努力传输的，不保证可靠性</li></ul><h3 id="4、拥塞控制、流量控制"><a href="#4、拥塞控制、流量控制" class="headerlink" title="4、拥塞控制、流量控制"></a>4、拥塞控制、流量控制</h3><ul><li>TCP有拥塞控制、流量控制，保证数据传输的安全性</li><li>UDP没有，网络拥塞也不会影响UDP的发送效率</li></ul><h3 id="5、首部开销"><a href="#5、首部开销" class="headerlink" title="5、首部开销"></a>5、首部开销</h3><ul><li>TCP首部如果没有使用【选项】字段是20字节</li><li>UDP首部只有8字节</li></ul><h3 id="6、传输方式"><a href="#6、传输方式" class="headerlink" title="6、传输方式"></a>6、传输方式</h3><ul><li>TCP是流式传输，没有边界，但保证顺序和可靠谱</li><li>UDP是一个包一个包的发送，有边界，但可能会丢包和乱序</li></ul><h3 id="7、分片不同"><a href="#7、分片不同" class="headerlink" title="7、分片不同"></a>7、分片不同</h3><ul><li>TCP的数据如果大于MSS大小，会在传输层分片</li><li>TCP的数据如果大于MTU大小，会在IP层分片<ul><li>MSS是MTU除去IP首部和TCP首部字节后的大小</li><li>MTU指最大传输单元，一般IP协议是1500字节</li></ul></li></ul><h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h2><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220430120840620.png" alt="TCP头部图解"></p><ul><li>序列号：在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，<strong>⽤来解决⽹络包乱序问题。</strong></li><li>应答号：指下⼀次「期望」收到的数据的序列号，<strong>⽤来解决不丢包的问题。</strong></li><li>控制位<ul><li>ACK：该位为 <code>1</code> 时，「确认应答」的字段变为有效</li><li>SYN: 该位为 <code>1</code> 时，表示希望建⽴连接</li><li>FIN: 该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。</li><li>RST: 该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接</li></ul></li></ul><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><ul><li><p>开始握手状态</p><ul><li>一开始客户端服务端都处于<code>CLOSE</code>状态</li><li>服务端进入<code>LISTEN</code>状态</li></ul></li><li><p>第一次握手</p><ul><li>客户端发送SYN报文，请求序列号为客户端随机生成</li><li>客户端进入<code>SYN_SEND</code>状态</li></ul></li><li><p>第二次握手</p><ul><li>服务端收到SYN报文，确认应答，应答号为客户端请求序列化+1</li><li>服务端发起SYN报文，序列号为服务端随机生成</li><li>两次请求可以合成一次</li><li>服务端进入<code>SYN_RCVD</code>状态</li></ul></li><li><p>第三次握手</p><ul><li>客户端收到服务端发来的请求，确认应答，应答序列号为服务端序列号+1</li><li>客户端处于<code>ESTABLISHED</code>状态，服务端收到请求后同样处于<code>ESTABLISHED</code>状态</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220430181008947.png" alt="TCP三次握手图解"></p><h3 id="为什么是三次握手，不是两次或者四次"><a href="#为什么是三次握手，不是两次或者四次" class="headerlink" title="为什么是三次握手，不是两次或者四次"></a>为什么是三次握手，不是两次或者四次</h3><ul><li>因为三次握手才能确认双方都有发送和接收能力</li><li>防止重复历史连接的初始化</li><li>同步序列号</li><li>避免资源浪费</li><li>两次握手不能做到上述事情</li><li>四次握手是冗余的</li></ul><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><ul><li><p>第一次挥手</p><ul><li>客户端发送FIN报文</li><li>进入FIN_WAIT1状态</li></ul></li><li><p>第二次挥手</p><ul><li>服务端发送ACK报文</li><li>进入CLOSED_WAIT状态</li><li>客户端收到ACK报文后进入FIN_WAIT2状态</li></ul></li><li><p>第三次挥手</p><ul><li>服务端发送FIN报文</li><li>进入LAST_ACK状态</li></ul></li><li><p>第四次挥手</p><ul><li>客户端发送ACK报文</li><li>进入TIME_WAIT状态</li><li>如无异常 客户端会在2MSL后进入CLOSE状态</li><li>服务端在收到ACK报文后，进入CLOSE状态</li></ul><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220430223120444.png" alt="TCP四次挥手图解"></p></li><li><p>MSL（maximum segment lifetime）：最大报文生成时间</p></li></ul><h3 id="为什么需要挥手四次"><a href="#为什么需要挥手四次" class="headerlink" title="为什么需要挥手四次"></a>为什么需要挥手四次</h3><ul><li>FIN报文可以由任一方发起，客户端发送FIN报文，仅仅表示客户端不再发送数据了但是还能接收数据</li><li>服务端收到FIN报文后，需要先发送ACK报文确认收到，防止重发，服务端可能还有数据需要处理和发送，等服务端不再发送数据时，再发送FIN报文给客户端</li></ul><h3 id="为什么需要TIME-WAIT状态"><a href="#为什么需要TIME-WAIT状态" class="headerlink" title="为什么需要TIME_WAIT状态"></a>为什么需要TIME_WAIT状态</h3><ul><li>防止具有相同四元组的旧数据包被收到<ul><li>四元组是指【源IP 目标IP 源端口 目标端口】</li><li>经过2MSL时间，旧的数据包会自然小时</li></ul></li><li>帮助被动关闭端正常关闭连接<ul><li>如果发送的ACK报文在超过MSL时间内没有被服务端接收，</li><li>服务端就会重发FIN报文</li><li>这也说明了为什么TIME_WAIT等待的时间2MSL，即客户端的ACK报文和服务端重发FIN报文最久是2MSL</li></ul></li></ul><h2 id="为什么TIME-WAIT等待的时间是2MSL"><a href="#为什么TIME-WAIT等待的时间是2MSL" class="headerlink" title="为什么TIME_WAIT等待的时间是2MSL"></a>为什么TIME_WAIT等待的时间是2MSL</h2><ul><li>如果发送的ACK报文在超过MSL时间内没有被服务端接收，</li><li>服务端就会重发FIN报文</li><li>这也说明了为什么TIME_WAIT等待的时间2MSL，即客户端的ACK报文和服务端重发FIN报文最久是2MSL</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS基本知识学习</title>
    <link href="/2022/04/24/HTTPS%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/04/24/HTTPS%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTPS的基本认识"><a href="#HTTPS的基本认识" class="headerlink" title="HTTPS的基本认识"></a>HTTPS的基本认识</h1><blockquote><p>HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和[身份认证]保证了传输过程的安全性</p></blockquote><h2 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h2><ul><li>无状态</li><li>明文传输</li><li>不安全</li></ul><h2 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h2><ul><li> HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在</li></ul><p>  TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输</p><ul><li><p>HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之</p><p>后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输</p></li><li><p>HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443</p></li><li><p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</p></li></ul><h2 id="HTTPS解决的问题"><a href="#HTTPS解决的问题" class="headerlink" title="HTTPS解决的问题"></a>HTTPS解决的问题</h2><ul><li>窃听风险，HTTP是明文传输，通行内容很容易被窃取</li><li>篡改风险，强制植⼊垃圾⼴告，视觉污染</li><li>冒充风险，冒充知名网站，如京东，淘宝</li></ul><h2 id="HTTPS解决的方案"><a href="#HTTPS解决的方案" class="headerlink" title="HTTPS解决的方案"></a>HTTPS解决的方案</h2><h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><ul><li>在SSL/TLS握手中，使用非对称加密算法加密</li><li>在SSL/TLS握手后，使用对称加密算法加密</li></ul><h4 id="SSL协议基本流程"><a href="#SSL协议基本流程" class="headerlink" title="SSL协议基本流程"></a>SSL协议基本流程</h4><ul><li>客户端向服务器索要并验证服务器的公钥</li><li>双⽅协商⽣产「会话秘钥」</li><li>双⽅采⽤「会话秘钥」进⾏加密通信 </li></ul><h3 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h3><ul><li><strong>摘要算法</strong>⽤来实现<strong>完整性</strong>，能够为数据⽣成独⼀⽆⼆的「指纹」，⽤于校验数据的完整性，解决了篡改的⻛险</li></ul><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><ul><li>将<strong>服务器公钥放在数字证书</strong>，防止客户端在获取服务器公钥的时候被篡改</li></ul><h2 id="HTTPS建立连接的过程"><a href="#HTTPS建立连接的过程" class="headerlink" title="HTTPS建立连接的过程"></a>HTTPS建立连接的过程</h2><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220424145240412.png" alt="TLS握手过程"></p><h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><ul><li>客户端发起ClientHello<ul><li>服务器随机数C</li><li>支持的TLS版本</li><li>支持的加密套件</li></ul></li></ul><h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><ul><li><p>服务器回应ServerHello</p><ul><li><p>服务器随机数S</p></li><li><p>确认使用的加密通信协议版本</p></li><li><p>确认使用的加密方法</p></li><li><p>服务器证书</p></li></ul></li></ul><h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><ul><li>客户端回应<ul><li>验证证书的合法性</li><li>如果证书受信任，则发送经过服务器公钥加密的随机数</li><li>以后的通信使用会话秘钥加密发送</li><li>之前所有握手信息的摘要</li></ul></li></ul><h3 id="第四次握手"><a href="#第四次握手" class="headerlink" title="第四次握手"></a>第四次握手</h3><ul><li>服务端回应<ul><li>确认收到</li><li>以后的通信使用会话秘钥加密发送</li><li>之前所有握手信息的摘要</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTPS</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP基本知识学习</title>
    <link href="/2022/04/23/HTTP%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/04/23/HTTP%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP基础"><a href="#HTTP基础" class="headerlink" title="HTTP基础"></a>HTTP基础</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>HTTP</strong> <strong>是⼀个在计算机世界⾥专⻔在「两点」之间「传输」⽂字、图⽚、⾳频、视频等「超⽂本」数据的「约定和</strong></p><p><strong>规范」</strong></p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><h3 id="1XX"><a href="#1XX" class="headerlink" title="1XX"></a>1XX</h3><ul><li>类状态码属于<strong>提示信息</strong>，是协议处理中的⼀种中间状态，实际⽤到的⽐较少</li></ul><h3 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h3><blockquote><p>2xx 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p></blockquote><h4 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h4><ul><li>是最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会有 body数据。</li></ul><h4 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h4><ul><li>也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据</li></ul><h4 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h4><ul><li>是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，⽽是其中的⼀部分，也是服务器处理成功的状态。</li></ul><h3 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h3><blockquote><p>3xx 类状态码表示客户端请求的资源发送了变动，需要客户端⽤新的 URL ᯿新发送请求获取资源，也就是<strong>重定向</strong>。</p></blockquote><h4 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 <strong>Moved Permanently</strong></h4><ul><li>表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问</li></ul><h4 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a><strong>302 Found</strong></h4><ul><li><p>表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。</p><p><code>301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动重定向新的 URL。</code></p></li></ul><h4 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a><strong>304 Not Modified</strong></h4><ul><li>不具有跳转的含义，表示资源未修改，᯿定向已存在的缓冲⽂件，也称缓存᯿定向，⽤于缓·存控制。</li></ul><h3 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h3><blockquote><p>4xx 类状态码表示客户端发送的<strong>报⽂有误</strong>，服务器⽆法处理，也就是错误码的含义。</p></blockquote><h4 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h4><ul><li>表示客户端请求的报文有错误，但只是个笼统的错误</li></ul><h4 id="403Forbdden"><a href="#403Forbdden" class="headerlink" title="403Forbdden"></a>403Forbdden</h4><ul><li>表示服务器禁止访问资源，但不是客户端的请求出错</li></ul><h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h4><ul><li>表示请求的资源在服务器不存在或未找到</li></ul><h3 id="4XX-1"><a href="#4XX-1" class="headerlink" title="4XX"></a>4XX</h3><h3 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h3><blockquote><p>5xx 类状态码表示客户端请求报⽂正确，但是<strong>服务器处理时内部发⽣了错误</strong>，属于服务器端的错误码。</p></blockquote><h4 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h4><ul><li>表示服务器内部出错，跟400一样也是个笼统的错误</li></ul><h4 id="501-Not-Implemented"><a href="#501-Not-Implemented" class="headerlink" title="501 Not Implemented"></a>501 Not Implemented</h4><ul><li>表示客户端请求的功能不支持，有”即将开业，敬请期待“的意思</li></ul><h4 id="502-Bad-Getaway"><a href="#502-Bad-Getaway" class="headerlink" title="502 Bad Getaway"></a>502 Bad Getaway</h4><ul><li>通常是服务器作为网关火代理时返回的错误码，表示服务器自身工作正常， 访问后端服务器发生了错误</li></ul><h4 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h4><ul><li>表示服务器当前很忙，暂时无法响应服务器</li></ul><h2 id="头部常见字段"><a href="#头部常见字段" class="headerlink" title="头部常见字段"></a>头部常见字段</h2><h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><ul><li>客户端发送请求时，⽤来指定服务器的域名。</li><li>作用：可以将请求发往「同⼀台」服务器上的不同⽹站。</li></ul><h3 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h3><ul><li>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据⻓度,后⾯的字节就属于下⼀个回应了。</li></ul><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><ul><li><p>字段最常⽤于客户端要求服务器使⽤ TCP 持久连接，以便其他请求复⽤</p></li><li><p>HTTP/1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为</p><p><code>Keep-Alive </code></p></li></ul><h3 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h3><ul><li>字段用于客户端请求时，表明⾃⼰可以接受哪些数据格式</li></ul><h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h3><ul><li>字段⽤于服务器回应时，告诉客户端，本次数据是什么格式。</li></ul><h3 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h3><ul><li>字段用于客户端请求时，表明自己可以接受哪些压缩方法</li></ul><h3 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h3><ul><li>字段说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式</li></ul><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><ul><li>GET方法用于使用给定的URI从给定服务器中检索信息，即从指定资源中请求数据。使用GET方法的请求应该只是检索数据，并且不应对数据产生其他影响，因此具有<strong>幂等性</strong></li></ul><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><ul><li>和GET方法的行为很类似，但服务器在响应中只返回头部信息</li></ul><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><ul><li>新增或提交数据。会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。</li></ul><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><ul><li>用于将数据发送到服务器以创建或更新资源，它可以用上传的内容替换目标资源中的所有当前内容，是<strong>幂等</strong>的</li></ul><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><ul><li>用来删除指定的资源，它会删除URI给出的目标资源的所有当前内容</li></ul><h4 id="TRACE、OPTIONS、CONNECT"><a href="#TRACE、OPTIONS、CONNECT" class="headerlink" title="TRACE、OPTIONS、CONNECT"></a>TRACE、OPTIONS、CONNECT</h4><ul><li>实际开发中基本不使用</li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>简单</li><li>灵活易拓展</li><li>跨平台</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>无状态</li><li>明文传输</li><li>不安全<ul><li>明文传输可能被监听</li><li>不知道通行放的身份，可能遭遇伪装</li><li>无法证明报文的完整性</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>protobuf在gRPC中的应用</title>
    <link href="/2022/04/15/protobuf%E5%9C%A8grpc%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2022/04/15/protobuf%E5%9C%A8grpc%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="protobuf在gRPC中的应用"><a href="#protobuf在gRPC中的应用" class="headerlink" title="protobuf在gRPC中的应用"></a>protobuf在gRPC中的应用</h1><blockquote><p>前面已经介绍了protobuf，这里我们先介绍了gRPC，了解gRPC前先了解下什么是RPC</p></blockquote><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><blockquote><p><code>RPC</code>也就是<code>remote procedure call </code>翻译过来就是远程过程调用，RPC是一种概念，grpc实现rpc的一种框架</p></blockquote><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220416093007487.png" alt="RPC流程图"></p><ul><li>stub是桩代码的意思，可以理解为存根</li><li>client stub：存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。</li><li>server stub：接收客户端发送过来的消息，将消息解包，并调用本地的方法。</li></ul><h3 id="RPC需要解决的三个问题"><a href="#RPC需要解决的三个问题" class="headerlink" title="RPC需要解决的三个问题"></a>RPC需要解决的三个问题</h3><ul><li>通信问题</li><li>序列化和反序列问题</li><li>call ID 映射问题</li></ul><h2 id="protobuf在gRPC中的应用-1"><a href="#protobuf在gRPC中的应用-1" class="headerlink" title="protobuf在gRPC中的应用"></a>protobuf在gRPC中的应用</h2><blockquote><p>protobuf在gRPC中的角色的接口定义语言，即解决的是序列化和反序列化的问题,而对于protobu来说，gprc只是生成service代码的一种工具</p></blockquote><h3 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h3><ul><li>新建hello.proto</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package=<span class="hljs-string">&quot;./;hello&quot;</span>;<br><span class="hljs-keyword">service </span><span class="hljs-title class_">HelloService</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello (HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br>&#125;<br>  <br>  <span class="hljs-keyword">message </span><span class="hljs-title class_">HelloRequest</span> &#123;<br>    <span class="hljs-type">string</span> greeting = <span class="hljs-number">1</span>;<br>&#125;<br>  <br>  <span class="hljs-keyword">message </span><span class="hljs-title class_">HelloResponse</span> &#123;<br>    <span class="hljs-type">string</span> reply = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="生成接口代码"><a href="#生成接口代码" class="headerlink" title="生成接口代码"></a>生成接口代码</h3><ul><li><p>运行bash命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ protoc --go_out=plugins=grpc:. .\hello.proto<br></code></pre></td></tr></table></figure></li><li><p>得到hello.pb.go文件</p></li></ul><h3 id="调用接口"><a href="#调用接口" class="headerlink" title="调用接口"></a>调用接口</h3><h4 id="server代码"><a href="#server代码" class="headerlink" title="server代码"></a>server代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>port = flag.Int(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-number">50051</span>, <span class="hljs-string">&quot;The server port&quot;</span>)<br>)<br><br><span class="hljs-keyword">type</span> server <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// can be embedded to have forward compatible implementations.</span><br>helloworld.UnimplementedGreeterServer<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *server)</span></span> SayHello(ctx context.Context, in *helloworld.HelloRequest) (*helloworld.HelloReply, <span class="hljs-type">error</span>) &#123;<br>log.Printf(<span class="hljs-string">&quot;Received:%v&quot;</span>, in.GetName())<br><span class="hljs-keyword">return</span> &amp;helloworld.HelloReply&#123;Message: <span class="hljs-string">&quot;Hello&quot;</span> + in.GetName()&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;:%d&quot;</span>, *port))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to listen:%v&quot;</span>, err)<br>&#125;<br><br>s := grpc.NewServer()<br>helloworld.RegisterGreeterServer(s, &amp;server&#123;&#125;)<br>log.Printf(<span class="hljs-string">&quot;server listening at %v&quot;</span>, lis.Addr())<br><span class="hljs-keyword">if</span> err := s.Serve(lis); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to serve:%v&quot;</span>, err)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="client代码"><a href="#client代码" class="headerlink" title="client代码"></a>client代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>defaultName = <span class="hljs-string">&quot;world&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>addr = flag.String(<span class="hljs-string">&quot;addr&quot;</span>, <span class="hljs-string">&quot;localhost:50051&quot;</span>, <span class="hljs-string">&quot;the address to connet to&quot;</span>)<br>name = flag.String(<span class="hljs-string">&quot;name&quot;</span>, defaultName, <span class="hljs-string">&quot;Name to greet&quot;</span>)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br>conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;did not connect :%v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br>c := helloworld.NewGreeterClient(conn)<br>ctx, cancel := context.WithTimeout(context.Background(), time.Second)<br><span class="hljs-keyword">defer</span> cancel()<br><br>reply, err := c.SayHello(ctx, &amp;helloworld.HelloRequest&#123;Name: *name&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;could not greet:%v&quot;</span>, err)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;Greeting: %s&quot;</span>, reply.GetMessage())<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="自定义protobu生成代码"><a href="#自定义protobu生成代码" class="headerlink" title="自定义protobu生成代码"></a>自定义protobu生成代码</h2><blockquote><p>Protobuf的protoc编译器是通过插件机制实现对不同语言的支持。比如protoc命令出现<code>--xxx_out</code>格式的参数，那么protoc将首先查询是否有内置的xxx插件，如果没有内置的xxx插件那么将继续查询当前系统中是否存在protoc-gen-xxx命名的可执行程序，最终通过查询到的插件生成代码。对于Go语言的protoc-gen-go插件来说，里面又实现了一层静态插件系统。比如protoc-gen-go内置了一个gRPC插件，用户可以通过<code>--go_out=plugins=grpc</code>参数来生成gRPC相关代码，否则只会针对message生成相关代码。</p></blockquote><p>参考gRPC的源码，插件是有generator.RegisterPlugin函数来的注册的，插件是一个generator.Plugin接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A Plugin provides functionality to add to the output during Go code generation,</span><br><span class="hljs-comment">// such as to produce RPC stubs.</span><br><span class="hljs-keyword">type</span> Plugin <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Name identifies the plugin.</span><br>Name() <span class="hljs-type">string</span><br><span class="hljs-comment">// Init is called once after data structures are built but before</span><br><span class="hljs-comment">// code generation begins.</span><br>Init(g *Generator)<br><span class="hljs-comment">// Generate produces the code generated by the plugin for this file,</span><br><span class="hljs-comment">// except for the imports, by calling the generator&#x27;s methods P, In, and Out.</span><br>Generate(file *FileDescriptor)<br><span class="hljs-comment">// GenerateImports produces the import declarations for this file.</span><br><span class="hljs-comment">// It is called after Generate.</span><br>GenerateImports(file *FileDescriptor)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Name方法返回插件的名字</li><li>g参数包含proto文件的全部信息</li><li>Generate用于生成主体代码</li><li>GenerateImport生成对应的导入包代码</li></ul><h3 id="插件代码"><a href="#插件代码" class="headerlink" title="插件代码"></a>插件代码</h3><ul><li>新建文件夹custom-plugin</li><li>在custom-plugin中新建文件netRpcPlugin.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> customplugin<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/golang/protobuf/protoc-gen-go/descriptor&quot;</span><br><span class="hljs-string">&quot;github.com/golang/protobuf/protoc-gen-go/generator&quot;</span><br>)<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 注册插件</span><br>generator.RegisterPlugin(<span class="hljs-built_in">new</span>(netRpcPlugin))<br>&#125;<br><br><span class="hljs-keyword">type</span> netRpcPlugin <span class="hljs-keyword">struct</span> &#123;<br>*generator.Generator<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *netRpcPlugin)</span></span> Name() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;netrpc&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *netRpcPlugin)</span></span> Init(g *generator.Generator) &#123;<br>p.Generator = g<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *netRpcPlugin)</span></span> GenerateImports(file *generator.FileDescriptor) &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(file.Service) &gt; <span class="hljs-number">0</span> &#123;<br>p.genImportCode(file)<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *netRpcPlugin)</span></span> Generate(file *generator.FileDescriptor) &#123;<br><span class="hljs-keyword">for</span> _, svc := <span class="hljs-keyword">range</span> file.Service &#123;<br>p.genServiceCode(svc)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *netRpcPlugin)</span></span> genImportCode(file *generator.FileDescriptor) &#123;<br>p.P(<span class="hljs-string">&quot;// TODO:import code&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *netRpcPlugin)</span></span> genServiceCode(svc *descriptor.ServiceDescriptorProto) &#123;<br>p.P(<span class="hljs-string">&quot;// TODO:service code,Name = &quot;</span> + svc.GetName())<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="编译main代码"><a href="#编译main代码" class="headerlink" title="编译main代码"></a>编译main代码</h3><blockquote><p>因为Go语言的包只能静态导入，我们无法向已经安装的protoc-gen-go添加我们新编写的插件。我们将重新克隆protoc-gen-go对应的main函数</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-comment">// 导包初始化</span><br>_ <span class="hljs-string">&quot;blog/custom-plugin&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><br><span class="hljs-string">&quot;github.com/golang/protobuf/protoc-gen-go/generator&quot;</span><br><span class="hljs-string">&quot;google.golang.org/protobuf/proto&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>g := generator.New()<br><br>data, err := ioutil.ReadAll(os.Stdin)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>g.Error(err, <span class="hljs-string">&quot;reading input&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> err := proto.Unmarshal(data, g.Request); err != <span class="hljs-literal">nil</span> &#123;<br>g.Error(err, <span class="hljs-string">&quot;parsing input proto&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(g.Request.FileToGenerate) == <span class="hljs-number">0</span> &#123;<br>g.Fail(<span class="hljs-string">&quot;no files to generate&quot;</span>)<br>&#125;<br>g.CommandLineParameters(g.Request.GetParameter())<br><br>g.WrapTypes()<br>g.SetPackageNames()<br>g.GenerateAllFiles()<br>data, err = proto.Marshal(g.Response)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>g.Error(err, <span class="hljs-string">&quot;failer to marshal output proto&quot;</span>)<br>&#125;<br>_, err = os.Stdout.Write(data)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>g.Error(err, <span class="hljs-string">&quot;failed to write output proto&quot;</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>运行bash指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go build -o  protoc-gen-go-netrpc.exe .<br></code></pre></td></tr></table></figure><p>将生成的程序剪贴到$GOPATH$/bin中</p></li></ul><h3 id="重新编译proto文件"><a href="#重新编译proto文件" class="headerlink" title="重新编译proto文件"></a>重新编译proto文件</h3><ul><li><p>运行bash指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ protoc --go-netrpc_out=plugins=netrpc:. hello.proto<br></code></pre></td></tr></table></figure><p>其中<code>--go-netrpc_out</code>参数告知protoc编译器加载名为protoc-gen-go-netrpc的插件，插件中的<code>plugins=netrpc</code>指示启用内部唯一的名为netrpc的netrpcPlugin插件。在新生成的hello.pb.go文件中将包含增加的注释代码。</p></li></ul><p>参考：</p><ul><li>[1]<a href="https://grpc.io/docs/languages/go/basics/">https://grpc.io/docs/languages/go/basics/</a></li><li>[2]<a href="https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-02-pb-intro.html">https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-02-pb-intro.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>protobuf</category>
      
      <category>gRPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>protobuf</tag>
      
      <tag>grpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识protobuf</title>
    <link href="/2022/04/11/protobuf%E5%9C%A8go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/04/11/protobuf%E5%9C%A8go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="初识protobuf"><a href="#初识protobuf" class="headerlink" title="初识protobuf"></a>初识protobuf</h1><blockquote><p>Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.</p></blockquote><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><ul><li><p>进入<a href="https://github.com/protocolbuffers/protobuf/releases">下载地址</a>选择对应的系统版本和语言下载</p></li><li><p>双击解压</p></li><li><p>并将其配置到系统环境变量中</p></li><li><p>控制台输入protoc –version查看是否安装成功</p></li><li><p>安装go语言版本的代码生成插件<code>go get github.com/golang/protobuf/protoc-gen-go</code></p></li></ul><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="定义消息类型"><a href="#定义消息类型" class="headerlink" title="定义消息类型"></a>定义消息类型</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package=<span class="hljs-string">&quot;./;hello&quot;</span>;<br><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span>&#123;<br>    <span class="hljs-type">string</span> query = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int32</span> page_number = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int32</span> result_per_page = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>syntax = &quot;proto3&quot;;</code>表示使用的是proto3语法，如果没有这一句的话默认使用的是proto2的语法</p></li><li><p><code>SearchRequest</code>表示该消息的名字</p></li><li><p>消息包含的三个字段，并非传统的键值对，例如<code>string query=1</code>表示字段的类型是string，字段的名字是query，字段编号是1</p></li><li><p><code>option go_package</code>中两个参数<code>./</code>和<code>hello</code>，分别表示生成的go文件的存放地址和go文件所属的包名</p></li></ul><h4 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h4><ul><li>示例中的三个字段都为标量字段，也可是枚举或者自定义的复合类型</li></ul><h4 id="字段编号"><a href="#字段编号" class="headerlink" title="字段编号"></a>字段编号</h4><ul><li>消息定义中的每个字段都需要一个<strong>唯一</strong>的编号，这些编号是在消息二进制序列化标识字段的</li><li>编号的范围为1~2^29-1</li><li>不能使用19000~19999，这些是protobuf内置的保留字段编号</li><li>同样的，也不能使用自己的保留字段编号</li></ul><h4 id="字段规则"><a href="#字段规则" class="headerlink" title="字段规则"></a>字段规则</h4><ul><li>字段默认出现为0或1次</li><li><code>repeated</code>：该字段可以在消息中出现重复任意次数（包括零次）。重复值的顺序将被保留。只能标量类型字段使用</li><li>字段规则加在类型前面</li></ul><h4 id="保留字段"><a href="#保留字段" class="headerlink" title="保留字段"></a>保留字段</h4><blockquote><p>即不能使用的字段编号或字段名称，否则编译器就会报错</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">Foo</span> &#123;<br>  reserved <span class="hljs-number">2</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span> to <span class="hljs-number">11</span>;<br>  reserved <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>编译该段proto程序</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><span class="hljs-keyword">option</span> go_package=<span class="hljs-string">&quot;./;hello&quot;</span>;<br><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span>&#123;<br>    <span class="hljs-type">string</span> query = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int32</span> page_number = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int32</span> result_per_page = <span class="hljs-number">3</span>;<br>    reserved <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>会出现错误信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hello.proto: Field <span class="hljs-string">&quot;page_number&quot;</span> uses reserved number 2.<br></code></pre></td></tr></table></figure></li></ul><h3 id="proto类型和go类型对比"><a href="#proto类型和go类型对比" class="headerlink" title="proto类型和go类型对比"></a>proto类型和go类型对比</h3><table><thead><tr><th align="center">.proto Type</th><th align="center">Go Type</th></tr></thead><tbody><tr><td align="center">double</td><td align="center">float64</td></tr><tr><td align="center">float</td><td align="center">float32</td></tr><tr><td align="center">int32</td><td align="center">int32</td></tr><tr><td align="center">int64</td><td align="center">int64</td></tr><tr><td align="center">uint32</td><td align="center">uint32</td></tr><tr><td align="center">uint64</td><td align="center">uint64</td></tr><tr><td align="center">sint32</td><td align="center">int32</td></tr><tr><td align="center">sint64</td><td align="center">int64</td></tr><tr><td align="center">fixed32</td><td align="center">uint32</td></tr><tr><td align="center">fixed64</td><td align="center">uint64</td></tr><tr><td align="center">sfixed32</td><td align="center">int32</td></tr><tr><td align="center">sfixed64</td><td align="center">int64</td></tr><tr><td align="center">bool</td><td align="center">bool</td></tr><tr><td align="center">string</td><td align="center">string</td></tr><tr><td align="center">bytes</td><td align="center">[]byte</td></tr></tbody></table><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><blockquote><p>解析编码时，如果字段没有被赋值，则使用默认值</p></blockquote><ul><li>对于字符串，默认值为空字符串。</li><li>对于字节，默认值为空字节。</li><li>对于布尔值，默认值为 false。</li><li>对于数字类型，默认值为零。</li><li>对于enums，默认值是第一个定义的 enum value，它必须是 0。</li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><blockquote><p>枚举第一个元素必须为0</p></blockquote><ul><li><p>消息中的枚举</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchRequest</span> &#123;<br>  <span class="hljs-keyword">enum </span><span class="hljs-title class_">Corpus</span> &#123;<br>    UNIVERSAL = <span class="hljs-number">0</span>;<br>    WEB = <span class="hljs-number">1</span>;<br>    IMAGES = <span class="hljs-number">2</span>;<br>    LOCAL = <span class="hljs-number">3</span>;<br>    NEWS = <span class="hljs-number">4</span>;<br>    PRODUCTS = <span class="hljs-number">5</span>;<br>    VIDEO = <span class="hljs-number">6</span>;<br>  &#125;<br>  Corpus corpus = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对于消息中的枚举（如上面的枚举），类型名称以消息名称开头：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SearchRequest_Corpus <span class="hljs-type">int32</span><br></code></pre></td></tr></table></figure></li><li><p>对于包级的枚举</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">enum </span><span class="hljs-title class_">Foo</span> &#123;<br>  DEFAULT_BAR = <span class="hljs-number">0</span>;<br>  BAR_BELLS = <span class="hljs-number">1</span>;<br>  BAR_B_CUE = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>类型名称则为原始枚举名称</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Foo <span class="hljs-type">int32</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="使用其他消息类型"><a href="#使用其他消息类型" class="headerlink" title="使用其他消息类型"></a>使用其他消息类型</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchResponse</span> &#123;<br>  <span class="hljs-keyword">repeated</span> Result results = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">Result</span> &#123;<br>  <span class="hljs-type">string</span> url = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">string</span> title = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> snippets = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">SearchResponse</span> &#123;<br>  <span class="hljs-keyword">message </span><span class="hljs-title class_">Result</span> &#123;<br>    <span class="hljs-type">string</span> url = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">string</span> title = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">repeated</span> <span class="hljs-type">string</span> snippets = <span class="hljs-number">3</span>;<br>  &#125;<br>  <span class="hljs-keyword">repeated</span> Result results = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">map&lt;key_type, value_type&gt; map_field = N;<br></code></pre></td></tr></table></figure><ul><li>map字段不能是<code>repeated</code></li><li>map中的key可以是除enum和float之外的任何标量</li></ul><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">service </span><span class="hljs-title class_">SearchService</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> Search(SearchRequest) <span class="hljs-keyword">returns</span> (SearchResponse)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>利用grpc插件生成代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ protoc --go_out=plugins=grpc:. hello.proto<br></code></pre></td></tr></table></figure></li></ul><p>参考：</p><p>[1]<a href="https://developers.google.cn/protocol-buffers/docs/proto3">https://developers.google.cn/protocol-buffers/docs/proto3</a></p><p>[2]<a href="https://developers.google.cn/protocol-buffers/docs/reference/go-generated">https://developers.google.cn/protocol-buffers/docs/reference/go-generated</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
      <category>protobuf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>protobuf</tag>
      
      <tag>数据传输</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis缓存一致性问题</title>
    <link href="/2022/04/07/Redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2022/04/07/Redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="redis缓存一致性问题"><a href="#redis缓存一致性问题" class="headerlink" title="redis缓存一致性问题"></a>redis缓存一致性问题</h1><blockquote><p>在实际业务中，经常会涉及到缓存，那么保持缓存数据和数据库数据之间的一致性同样是一个非常重要的举措</p></blockquote><h2 id="三种常见的缓存更新方案"><a href="#三种常见的缓存更新方案" class="headerlink" title="三种常见的缓存更新方案"></a>三种常见的缓存更新方案</h2><h3 id="方案一-先更新数据库，再更新缓存"><a href="#方案一-先更新数据库，再更新缓存" class="headerlink" title="方案一| 先更新数据库，再更新缓存"></a>方案一| 先更新数据库，再更新缓存</h3><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220407153127364.png" alt="方案一流程"></p><p>问题：</p><ul><li>高并发时，如果线程A更新完数据库，线程B再次更新数据库，线程B比线程A先一步更新缓存，那么缓存还是线程A的数据，数据库是线程B的数据</li></ul><h3 id="方案二-先删除缓存，再更新数据库"><a href="#方案二-先删除缓存，再更新数据库" class="headerlink" title="方案二 | 先删除缓存，再更新数据库"></a>方案二 | 先删除缓存，再更新数据库</h3><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220407155035593.png" alt="方案二流程"></p><p>问题：</p><ul><li>线程A更新数据，先删除缓存，此时，线程B读取数据，因为此时线程A还未上锁，所以线程B可以从数据库读取数据，并且再次存入缓存中</li></ul><h4 id="改进-延时双删"><a href="#改进-延时双删" class="headerlink" title="改进| 延时双删"></a>改进| 延时双删</h4><ul><li>即根据业务需要，在延迟多少时间后再把缓存删除</li></ul><p>问题：</p><ul><li>延迟删除，会影响接口吞吐量，影响接口性能</li><li>第二次删除可能存在问题</li></ul><h3 id="方案三-先更新数据库，再删除缓存"><a href="#方案三-先更新数据库，再删除缓存" class="headerlink" title="方案三| 先更新数据库，再删除缓存"></a>方案三| 先更新数据库，再删除缓存</h3><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220407201533461.png" alt="方案三流程"></p><p>问题：</p><ul><li><p>线程A读取数据，恰好此时没有缓存时，从数据库读到旧值，线程B更新新值到数据库后删除缓存，删除缓存，线程A更新缓存</p></li><li><p>概率较低，数据库操作中极少出现查询比更新慢的情况</p></li></ul><h2 id="基于消息的队列-异步更新缓存"><a href="#基于消息的队列-异步更新缓存" class="headerlink" title="基于消息的队列| 异步更新缓存"></a>基于消息的队列| 异步更新缓存</h2><blockquote><p>基于订阅binlog的同步机制</p></blockquote><ul><li>模仿mysql的主从复制交互协议，将自己伪装成mysql slave 向mysql master 发送dump协议</li><li>mysql master收到dump请求，推送bin log给的slave</li><li>解析bin log对象</li><li>利用消息队列进行分发消费</li></ul><p><img src="https://raw.githubusercontent.com/GitWhitestorm/blog-image/master/img/image-20220407210105040.png" alt="binlog异步订阅流程"></p><h2 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h2><ul><li>给缓存添加过期时间可以保证缓存的最终一致性</li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>缓存</tag>
      
      <tag>一致性问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
